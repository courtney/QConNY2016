<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Algorithms for Animation - 3 simple formulas to activate your UI</title>

		<meta name="description" content="Algorithms for Animation - 3 simple formulas to activate your UI">
		<meta name="author" content="Courtney Hemphill">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">

		<link rel="stylesheet" href="css/theme/simple.css" id="theme">
		<link rel="stylesheet" href="css/animate.css">
		<link rel="stylesheet" href="css/qconny.css">
		<link rel="stylesheet" type="text/css" href="css/wd-icons.css" />

		<!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"> -->
		<!-- <link rel="stylesheet" href="css/component.css"> -->
		<link rel="stylesheet" href="css/spin.css">
		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
					
		
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- TODO: 					
					- expand on Disney's 12 principles & how animations came about
					- expand on what interpolation is and background
					- show simple version of algorithm and complex version (video?)
					- add in bad examples of animation after the good patterns
					- show some examples of CSS animation working in interfaces
					- use Material design lite
					- show some examples of more complex JS animations working
					- add in humor
					-->


				<section class="intro" id="QConNY2016" data-state="introduction">
					<div class="tagline"><div class="title">Algorithms for Animation</div>
					<div style="height: 2em;">Simple formulas to 
					  <span class="change-container">
					    <span class="changing">activate</span> 
					    <span class="changing">play</span> 
					    <span class="changing">inform with</span> 
					    <span class="changing">brand</span> 					    
					  </span> UI </div>
					</div>					
					<div class="c5-contact">
						<small>
							<a href="http://www.carbonfive.com">Courtney Hemphill</a>				
							<a href="mailto: courtney@carbonfive.com">courtney<em>@</em>carbonfive.com</a>
							<a href="http://twitter.com/chemphill"><em class="red">@</em>chemphill</a>
							#QConNewYork
						</small>						
					</div>							
					<aside class="notes">
						Good afternoon everyone. Thanks for joining<br/>
						This is a talk about algorithms, but make not mistake, I'm not a mathlete<br/>
						The message I'm trying to get across is actually how accessible algorithms are and how fun it can be to play with animations.<br/>
						Software is getting more and more complex on the client side<br/>
						Browsers are getting better and faster<br/>
						Since everything is now getting pushed to the cloud, it is hard to avoid developing for that environment at some point<br/>

						So this is about one small slice of that - animations.<br/>
						one part psychology<br/>
						one part math<br/>
						one part play<br/>					
					</aside>					
				</section>

				<section data-state="design-dev">					
					<aside class="notes">
						<p>There is however a meta purpose of this talk: bridging the design and development gap</p>
						<p>With creating software applications, we tend to see our work as distinctly in the code. The reality is that we might actually really enjoy the design aspect. Software engineers naturally design, it is just usually represented in code.</p>
						<p>We should also take into consider the greater experience design.</p>
						<p>How many of you consider yourselves a designer? Developer? Hybrid?</p>
						<p>Designing animations for software has always been a bit decoupled from the implementation.<br/>
						translating that onto web or mobile is always a bit tricky.</p> 
						<p>Developers can benefit by understanding basic principles behind animation design</p>
						<p>Everyone can play a role in adding life to the interface</p> 	
						<p>Math, and by extension physics, is the foundation of our reality (design, nature, beauty abstracted away gives us math formulas)</p>
					</aside>
				</section>

				<section data-state="pixar" data-background="img/disney.jpeg">

					<blockquote class="photo">
						"You can take a problem that can't be solved directly by <em class="red">animation</em> and can't be solved by <em class="red">technology</em> and work together to acheive a much better resolution."<br/>
						<span class="credit"> - Joe Longson, Senior Software Engineer - Zootopia</span>
					</blockquote>



					<aside class="notes">
						<p>So I really geek out on animation movies, mostly Pixar but really all of them. And the process of producing one of these moveis really facinates me.</p>
						<p>Creating the animation and lighting effects for today's movies requies huge server farms and super computers with somewhere around 55,000 cores.</p>
						<p>My friend who used to work at Dreamworks told me this great story about how they used to have to ship in generators because the power plant that was literally next door couldn't supply enough cooling energy</p>
						<p>400,000-plus computations per day require new animation techniques way beyond the scope of this talk.</p>
						<p>The most intersting thing though is how they were able to create less software by collaborating with the designers more closely and iterating on what might be possible.</p>
					</aside>
				</section>

				<section>
					<div style="font-size: 1em;">
						<span class="wd wd-database"> CLI </span>
						<span class="wd wd-chevron-right">&nbsp;</span>
						<span class="wd wd-layers"> GUI </span>
						<span class="wd wd-chevron-right">&nbsp;</span>
						<span class="wd wd-pointer-up"> NUI </span>
					</div>
					<aside class="notes">
						<p>So we're not making the next Nemo but the experiences in software are moving closer and closer to the real world</p>
						<p>Software is just layer upon layer of abstractions to get a machine to do something</p>
						<p>In the beginning, there was the command line interface. Now we have the GUI (WIMPs if you will, windows, icons, menus, pointer)(</p>
						<p>The next level is NUI or natural, using our fingers for touching, squishing, stretching and the sort of thing we see happening with Magic Leap and VR</p>
						<p>As we get closer to closer to something that looks like our "world" we have to consider how to make that experience not jarring.</p>
					</aside>
				</section>

				<section>
					<div style="background: url('img/chair.jpg') no-repeat 50% 100%; height: 570px; width: 900px;">						
						<h2>Affordance & <em class="red">percieved</em> affordance</h2>
					</div>		
					<aside class="notes">
						<p>What does it mean to "feel" right? how close does something uphold our view of reality?</p>
						<p>We attribute those things around us to have certain properties - this is called affordance.</p>
						<p>We will evaluate our experience with something new or novel to us (such as a new interface) by how close it feels to what we know.</p>
						<p>Based in our interaction with normal objects in our daily lives and hence in physics.</p>
						<p>So using visual metaphors, like a trash can, is one way to indicate something, like deletion, but motion is another.</p>
						        													
					</aside>					
				</section>

				<section data-background="img/brain.jpg">
					<h2 style="color: #fff; text-shadow: 2px 3px 3px #666;">Animations are cognitive aids</h2>														
					<aside class="notes">
						<p>In today's interfaces, the affordance of screens is change</p>					
						<p>We see things move on a screen and we assign a "perception of causality"</p>
						<p>As long as things represent real world physics, we will emotionally engage and intuit meaning from movement</p>
						<p>let's look at some examples of ways in which people are using animations to assist users</p>
					</aside>
				</section>

				<!--<section data-state="peripheral">-->
					<!--<video data-autoplay class="stretch" src="img/3941261.mp4"></video>-->
					<!--<aside class="notes">-->
						<!--<p>We recognize movement in our peripheral vision faster than changes in color.</p>-->
						<!--and definitely before we read any text-->
						<!--<p>Movement directs our attention</p>-->
						<!--<p>Movement triggers emotional response</p>-->
						<!--<p>New theories actually tie emotional responses to our rapid decision making (somatic-marker hypothesis)</p>-->
						<!--<p>Something that is getting more and more attention now is the timing of animations in interfaces, which I'll go into later</p>-->
						<!--<p>So we are hypersensitive to motion and therefore it needs to feel right</p>-->
						<!--&lt;!&ndash; <p>The somatic-marker hypothesis is a neurobiological theory of how decisions are made in the face of uncertain outcome.-->
						<!--This theory holds that such decisions are aided by emotions, in the form of bodily states,-->
						<!--that are elicited during the deliberation of future consequences and that mark different options for behavior as being advantageous or disadvantageous. This process involves an interplay between neural systems that elicit emotional/bodily states and neural systems that map these emotional/bodily states.</p> &ndash;&gt;-->
					<!--</aside>-->
				<!--</section>-->

				<section data-state="clippy">
					<div style="background: url('img/clippy.png') no-repeat 50% 100%; height: 570px; width: 900px;"></div>
					<aside class="notes">
						Animations have always been a part of good Graphical user interfaces. From the annoyingly animated Clippy to the almost equally annoying genie effect. we've suffered through bad animation and mostly ignored the good because it was in service of our primary goal
					</aside>
				</section>

				<section data-state="genie">
					<video data-autoplay class="stretch" src="img/genie.mov"></video>
					<aside class="notes">
						<p>It started out on desktop apps, but with the advent of better and better browser technology we can produce some of the same effects across environments</p>
					</aside>
				</section>



				<section>
					<h2><em class="red">Subtle</em> Cues</h2>
					<aside class="notes">
						<p>Really simple animations can do a lot to set up expectations</p>
						<p>animations can create an emotional reaction</p>
						<p>more and more brands are creating custom animation libraries and components to use in all their digital properties</p>
						<p>Apple built it directly into their developer platform, Facebook created a FIG (Facebook Interface Guidelines). Google sort of open sourced theirs with Material Design</p>
					</aside>
				</section>
				
				<section data-state="buttons">
					<iframe src="button-responses.html" width="920" height="800" frameborder="0"></iframe>
					<aside class="notes">
						<p>assistive and descriptive animation</p>
						<p>animation that creates emotional connection to a brand</p>
						<p>Allows the user to make a quick decision based on an emotional response to an animation</p>
						<p>Give quick feedback</p>						
						<p>It’s nice to feel like things are reacting to what you’re doing.</p>
					</aside>
				</section>	

				<section>
					<h2><em class="red">Progress</em>ive Disclosure</h2>
					<aside class="notes">
						<p>do your end users a favor and reduce cognitive load</p>
					</aside>
				</section>

				<section>
					<iframe src="one-line-form.html" width="920" height="800" frameborder="0"></iframe>
					<div class="attribution">CoDrops <br/> https://dribbble.com/ColinGarven</div>
					<aside class="notes">
						<p>if we had a piece of paper for every form we have filled out online we wouldn't have any forests left. bureacracy is alive and well just stored in huge data warehouses</p>
						<p>only show me what is relevant now and give them some feedback along the way. It's like asking directions from a very polite person with a nice british accent</p>
					</aside>
				</section>
						
				<section data-state="progressive-disclosure">
					<img src="img/progressive_disclosure.gif" class="fjs"/>
					<div class="attribution">Colin Garven <br/> https://dribbble.com/ColinGarven</div>
					<aside class="notes">
						<p>Error states that are easy on the eyes and keep a pace so that you can get what you need to get done and move along.</p>
						<p>Small moments like these are what adds to the overall brand voice and experience of a product.</p>
					</aside>
				</section>																					

				<section data-state="grid-demo" class="grid-demo">
					<h2>Auto Loading</h2>
					<aside class="notes">
						<p>Plays to our psychology to want to see what is around that next corner</p>
						<p>Almost like a slot machine</p>
					</aside>
				</section>	

				<section data-state="nav-demo">
					<h2><em class="red">Nav</em>igation</h2>
					<aside class="notes">
						<p>Animated transitions between screens convey logical relationships and create an understood "map" of an interface from how things enter and exit a screen.</p>						
						<p>death of breadcrumbs</p>
						<p>don't ask someone to read the fucking manual </p>
					</aside>
				</section>

				<section>
					<img src="img/ScrollingNoAnimation.gif" class="fjs"/>
					<div class="attribution">Adrian Zumbrunnen <br/> http://www.smashingmagazine.com/2013/10/23/smart-transitions-in-user-experience-design/</div>
					<aside class="notes">
						<p>Traditional anchor jump or worst a page load</p>						
					</aside>
				</section>

				<section>
					<img src="img/ScrollingAnimated.gif" class="fjs"/>
					<div class="attribution">Adrian Zumbrunnen <br/> http://www.smashingmagazine.com/2013/10/23/smart-transitions-in-user-experience-design/</div>
					<aside class="notes">
						<p>better</p>						
						<p>no reload and we now know that where the about section is, simple but used everywhere</p>						
					</aside>
				</section>								
			
			<!-- patterns/hamburger menu -->
			<!-- going from windows to apple -->
			<!-- people will take the time to learn a new pattern if it is easy, fun or an extension of something familiar -->
			<!-- normalize the patterns of an interface and make way for more nuanced abstractions. With enough time and exposure, a user can shed the padding and metaphors that become dead weight, like taking the training wheels off a bike. -->


				<section>
					<h2>Con<em class="red">text</em></h2>
					<aside class="notes">
						<p>always keep your users informed and knowing that something is happening</p>
						<p>context sensitive navigation</p>
					</aside>
				</section>
		
				<section>
					<img src="img/gboard.gif" class="fjs"/>
					<div class="attribution">Jason Zigrino<br/> https://dribbble.com/shots/2749851-Gboard-Dark-Material-Motion</div>
					<!--<video data-autoplay class="stretch" src="img/google.mkv"></video>-->
					<aside class="notes">
						<p>traditionaly this was the spinner or loading animation (which is still widely used)</p>
						<p>During the transition, the user is guided to the next view.<br/>
							The surface transforms to communicate hierarchy. Loading occurs behind the scenes to reduce perceived latency.</p>
					</aside>
				</section>

				<section>
					<h2>Inter<em class="red">active</em>	</h2>
					<aside class="notes">
						<p>today's users of software are more and more willing to expore on thier own</p>
						<p>We (meaning our kids) are also willing to play and discover things (snapchat anyone?)</p>
						<p>less clicking, less reading</p>
						<p>let your users explore and discover, make it fun</p>
					</aside>
				</section>

				<section>
					<img src="img/nav1.gif" class="fjs"/>
					<div class="attribution">Sergey Valiukh<br/> https://dribbble.com/SergeyValiukh</div>
				</section>

				<section>
					<h2>How do you communicate <em class="red">animation</em> ideas?</h2>	
					<aside class="notes">
							Wireframes only communicate very extreme states of animations - the devil is in the details<br/>
							<i>Wireframes and static comps leave us stuck in extreme states</i>
							<p>Making the motion feel right requires details</p>
						</aside>												
				</section>	

				<section>
					<h2><em class="red">Math</em></h2>
					<p><img src="img/math_heart.jpg" class="fjs"/></p>					
					<aside class="notes">												
						<p>Happily animation has its roots in some very easy math functions.</p>
						<p>You can then take basic functions and add in all sorts of complexity</p>
						<p>position, velocity, acceleration</p>
					</aside>
				</section>	

				<section data-state="keyframe">
					<img src="img/tweening.gif" class="fjs"/>					
					<aside class="notes">
						<p>Early animation techniques were developed by Windsor McCay</br>
						sequences of drawings by the best designers created key animations</p>
						<p>lackeys would draw the frames in between</p>
						<p>Instead of a human making the natural transitions betwee key frames, we use software to be the "inbetweener", which uses physics and math.</p>
						<p>Disney adopted this technique and came up with the "12 principles of animation design"</p>
					</aside>	
				</section>	

				<section data-state="basic-one">
					<h2>Motion</h2>
<pre>
var ball = document.getElementById('ball');
var start = 0;
var basicAnimation = function (e) {
	<em>start += 12;</em>	     
	<em>basic.style.left = start + "px";</em> 
  if (Math.abs(start) <= 800) {
    requestAnimationFrame(basicAnimation);
  }	
}</pre>
					<div class="basic-one-slide-background"><div id="basic-one"></div></div>						
					<aside class="notes">												
						<p>Simple addition of one pixel on another.</p>
						<p>Doesn't give much insight into where you are at within the animation - you know position but not necessarily how much progress has been made.</p>
						<p>Animation gets interesting when you can start to think of things in terms of percent changed</p>												
					</aside>
				</section>											

				<section class="interpolation">
					<h2>The basics of animation: <em class="red">interpolation</em></h2>
					<pre style="text-align: center; margin-top: 1em;">valueAtTime = (end - start) * time / duration + start</pre>			
					<aside class="notes">
						<p>One simple formula describes all animation. all based on time. where you want to start, go (change), total duration and then you can always get at where you are currently in the process<p>
						<p>To make these motions appear realistic, interpolation algorithms have been sought that approximate real life motion dynamics. </p>
						<p>custom algorithms, motions with unique, unnatural and entertaining visual characteristics</p>						
					</aside>
				</section>

				<section class="interpolation">
					<h2>The basics of animation: <em class="red">interpolation</em></h2>
					<pre style="text-align: center; margin-top: 1em;">valueAtTime = (end - start) * <em class="red">time / duration</em> + start</pre>
					<aside class="notes">
						<p>One simple formula describes all animation. all based on time. where you want to start, go (change), total duration and then you can always get at where you are currently in the process<p>
						<p>To make these motions appear realistic, interpolation algorithms have been sought that approximate real life motion dynamics. </p>
						<p>custom algorithms, motions with unique, unnatural and entertaining visual characteristics</p>
					</aside>
				</section>

				<!--<section>-->
					<!--<h2>Breaking it down to [0-1]</h2>		-->
					<!--<pre style="text-align: center; margin-top: 1em;">valueAtTime = <em class="red">(end - start)</em> * <em class="blue">time / duration</em> + start</pre>	-->
					<!--<p><em class="red">Change</em> @ <em class="blue">Percent Complete</em></p>-->
					<!--&lt;!&ndash; <p>change = end - start</p>			-->
					<!--<p>percent complete = time/duration</p>					 &ndash;&gt;-->
					<!--<aside class="notes">-->
						<!--<p>when making some kind of animation, we know the starting and ending positions, and want to transition between these. All of these can be converted to interpolation from 0 to 1.</p>-->

						<!-- - thinking about things in terms of percent complete-->
						<!--<p>you are trying to map everything into a point of reference between 0 and 1</p>-->
						<!--<p>multiply any value between 0 and 1 with another value between 0 and 1, and the result is guaranteed to be between 0 and 1.</p>-->
						<!--this will then work for everything - you will have your different parameters like position, color, shape, etc but you can map them to a value between 0 to 1-->
						<!---->
						<!--<p>So Interpolation allows you to start talking more generally and easily porting over whatever you need to put motion to into a very easy range of reference.</p>											-->
					<!--</aside>-->
				<!--</section>		-->

				<section data-state="basic-two">
					<h2>Timing</h2>
					<pre>
  (end - start) * <em>time/duration</em> + start
  div.style.left = 900-0 * <em>time/1000</em> + 0+"px"
</pre>
					<div class="basic-one-slide-background"><div id="basic-two"></div></div>
				<aside class="notes">
					<p>Now we have a consistent number to work with. All animations will fall in a range from [0-1]. The percentage of completion… </p>

					<p>What a property value is at any given time isn't nearly as important as how that property changed from its initial value to the final value over the lifetime of the animation. </p>
				</aside>
			</section>							
		
			<!--<section data-state="basic-three">-->
				<!--<div class="basic-one-slide-background"><div id="basic-three"></div></div>				-->
				<!--<aside class="notes">-->
					<!--Consistent, unvarying progress from beginning to end. Too mathmatetical... need something with some variety-->
				<!--</aside>-->
			<!--</section>-->

			<section data-state="basic-three">
				<img src="img/percentage.jpg" class="fjs" style="width: 50%"/>
				<aside class="notes">
					Consistent, unvarying progress from beginning to end. Too mathmatetical... need something with some variety
				</aside>
			</section>


				<section>
				<p>
					<blockquote>"Using a term like <em class="red">nonlinear</em> science is like referring to the bulk of zoology as the study of non-elephant animals."</blockquote>
				</p>
				- Stanislaw Ulam
				<aside class="notes">
					<p>The vast majority of mathematical equations and natural phenomena are nonlinear, with linearity being the exceptional, but important, case.</p>					

					<p>With Fermi and John Pasta, Ulam studied the Fermi–Pasta–Ulam problem, which became the inspiration for the vast field of Nonlinear Science.</p>
				</aside>
			</section>

				<section>
					<h2>Natural <em class="red">move</em>ment</h2>
					<p>Velocity, Acceleration, Friction, Torque</p>
					<aside class="notes">
						<p>nothing in our world moves linearly<br/>
							- nothing has perfectly maintained speed except in vacuums<br/>
							- we don’t live in vacuums, we live with friction and barriers and drag<br/>
							- we accelerate and decelerate at differing rates<br/>
							- we experience yaw, torque, etc<br/>
						</p>
					</aside>
				</section>
			
			<section>
				<h2>Easing <em class="red">fun</em>ctions</h2>	
				<img src="img/easeInCubic.png" class="fjs"/>
				<aside class="notes">
					Same beginning and end but with variation in the speed of execution. Start slow and move more quickly.
					<p> basically we're adding in acceleration</p>
				</aside>
			</section>
			
			<section>
				<h2>Easing</h2>	
				<pre>(end - start) * easingfunction([0-1]) + start</pre>
				<p>Change in <em class="red">property</em> times (some float) plus <em class="red">beginning value</em>.</p>
				<aside class="notes">
					Easing functions define the rate at which your property changes. All that matters is what percentage of the final property value has been reached at any given point during the animation's lifetime.
				</aside>
			</section>


			<section data-state="ease-anim">
				<h2>Power Functions - EaseIn</h2>	
				<img src="img/easeInCubic.png" class="fjs" style="width: 30%"/>			
				<pre class="med-code">endX * <em>Math.pow(percentChange, 3)</em> + "px";</pre>
				<div class="basic-one-slide-background"><div id="ease-anim"></div></div>								
				<aside class="notes">
					Now we get to start playing around with our animations. We can make them more organic and we can tweak our values to produce exactly the effect we are after.
					A great (and simple) starting point is the power function. 
					You can put any power in there and see if it meets your needs.
					So that is kinda sudden... and you don't always need to ferarri ... although who doesn't want the ferrari ...
				</aside>					
			</section>


			<section data-state="ease-out-anim">
				<h2>Power Functions - EaseOut</h2>		
				<img src="img/eastOutCubic.png" class="fjs" style="width: 30%"/>
				<pre class="med-code">(endX - startX)*<em>(1 - Math.pow(1 - (t / d), 3))</em> +startX+"px";</pre>
				<div class="basic-one-slide-background"><div id="ease-out-anim"></div></div>												
				<aside class="notes">
					We see this a little more used on the web. the slide in. This is back to the feeling that when a person walks into your periferral vision they already have velocity and then they slow down to a stop.
				</aside>		
			</section>


			<section data-state="ease-in-anim">
				<h2>Trig! ... sine :)</h2>	
				<img src="img/easeInSine.png" class="fjs" style="width: 30%"/>	
				<pre class="med-code">(endX - startX)*<em>Math.sin( t/d * Math.PI / 2 )</em> +startX+"px";</pre>
				<div class="basic-one-slide-background"><div id="ease-in-anim"></div></div>															
				<aside class="notes">
					So what if you need a bit of nuance, it isn't a ferrari and it isn't the enter and exit stage left scenario? Trig is what starts to get you towards the more powerful physics engines. These are how you can get really good at representing natural and organic movement. 
					It is subtle, but the devil is in the details and it is all about precise control.
					<p>
						Introducing time and motion changed everything for me, because what I realized was that it gave you precise control over the emotion you are trying to convey and how an audience will interpret your message. I’d often look to title sequences for inspiration because I was fascinated with how a 30 second or 3 minute sequence had the ability to set the tone for an entire film and foreshadow what was going to happen. 
					</p>
				</aside>
			</section>

			<section>
				<h2><em class="red">Follow</em> Through</h2>	
				<p> > 1</p>		
				<aside class="notes">
					<p>We can also go beyond that 0-1 range</p>
					<p>One of the 12 Basic Principles of Animation is Follow through or elastic movement. </p>
					<p>Follow through refers to an animation technique where things don't stop animating suddenly. They exceed their final target slightly before snapping back into place. This useful technique is something that can only be done by going beyond the 0-1 range.</p>
				</aside>					
			</section>


			<section data-state="elastic-anim">
				<h2>Elasticity</h2>	
				<img src="img/easeOutBack.png" class="fjs" style="width: 30%"/>	
				<pre class="med-code">(endX - startX)*<em>k * k * ( ( s + 1 ) * k - s )</em> +startX+"px";</pre>
				<div class="basic-one-slide-background"><div id="elastic-anim"></div></div>																			
				<aside class="notes">
					The math is getting a little more complicated now ... we're bringing in some additional factors but the basic underlying equation is still the same. you can pull most of the necessary functions from <strong>Robert Penner's easing functions</strong> or just check the source for tween.js. then you just plug and play and adjust values.
				</aside>
			</section>

			<section data-state="bounce-anim">
				<h2>Bounce</h2>	
				<img src="img/easeOutBounce.png" class="fjs" style="width: 30%"/>						
				<pre class="small-code">
if ( k < ( 1 / 2.75 ) ) { 
<em>return 7.5625 * k * k;</em>
} else if ( k < ( 2 / 2.75 ) ) { 
<em>return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;</em>
} else if ( k < ( 2.5 / 2.75 ) ) {	
<em>return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;</em>
} else { 
<em>return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375; } }</em>
				</pre>
				<div class="basic-one-slide-background"><div id="bounce-anim"></div></div>																			
				<aside class="notes">
					Bounce is everywhere. You drop something, likelihood it is going to bounce a bit before it settles. so this is starting to represents our physical world. It is also starting to introduce Newtonian physics to our animations. 
				</aside>
			</section>
			
			<section data-state="friction">
				<h2><em class="red">Physics</em> Engines</h2>	
				<aside class="notes">
					<p> As you get closer and closer to reality, the math starts to go from simple algebra to more complicated calculus.</p>
					<p>Things like damping of a spring. this is where things get pretty tricky but there are </p>				
					<p>There are many great javascript physics engines out there that take a lot of the leg work out of it for you. Diving into the source code can be fun though. </p>
					<p>flick gesture from inertial scroll</p>
					
					<p>Initial velocity of your finger then the program takes that slope and degrades it until zero</p>
				</aside>
			</section>

			<section data-state="flick-anim">
				<aside class="notes">
					<p>flick gesture from inertial scroll</p>
					<p>damping of a spring. this is where things get pretty tricky but there are </p>				
					<p>Initial velocity of your finger then the program takes that slope and degrades it until zero</p>
				</aside>
			</section>

			<section data-state="pe1">
					<h2>Linear Interpolation Function (start, <em class="red">stop</em>, amount)</h2>
				<pre>
function lerp(a,b,x) { return a+x*(b-a); }
				</pre>
					<aside class="notes">
						The lerp function is convenient for changing anything in a linear fashion.
					</aside>
			</section>

			<section data-state="pe2">
					<h2><em class="red">Rad</em>ial motion</h2>
				<pre>
<em class="red">anim.theta += .02*Math.pow(1-anim.r/cw,8) * Math.PI;</em>
anim.p.x = anim.r * Math.cos(anim.theta);
anim.p.y = anim.r * Math.sin(anim.theta);
				</pre>
					<aside class="notes">
						// Theta here is just how far from the center you are (polar notation)<br/>
						// Cartesian curves can be plotted on rectilinear axes, polar plots can be drawn on radial axes<br/>
						// changing angle based on radius. farther out the less we change it<br/>
						// galaxy planetary system<br/>
						// simulation of gravity, w/out the orbits taking into account<br/>
						// based on radius of canvas we have (cw)<br/>
						// whenever you can you should use relative positioning, allows you to scale by context (screensize)<br/>
						// animation is percentage of screen width<br/>
						// closer to the middle of the screen the higher your theta is and makes everything in the center go faster (delta theta is proportional to the distance from the center)<br/>
						// Math.pow is an aethetic thing, gives a bit more differentiation<br/>
						// really simple, just changing p.x and p.y<br/>
						The expression of a point as an ordered pair (r,theta) is known as polar notation, the equation of a curve expressed in polar coordinates is known as a polar equation, and a plot of a curve in polar coordinates is known as a polar plot.<br/>

					</aside>
			</section>

			<section data-state="pe3">
					<h2>Depth (varying <em class="red">velocity</em>)</h2>
				<pre class="med-code">
// different shaped circles (depth)
function shape() { return randomCircle(.006, .09) }

// initializes each circle w/ random velocity (px/second)
x:lerp(xmin,xmax,Math.random()),
y:lerp(ymin,ymax,Math.random())}

// basic equation: incremental x and/or y by velocity to get acceleration
<em class="red">anim.p.x += anim.v.x
anim.p.y += anim.v.y</em>

// this just keeps everything w/in the bounds of the canvas
anim.p.x = (anim.p.x + cw/2) % cw - cw/2
anim.p.y = (anim.p.y + ch/2) % ch - ch/2
				</pre>
					<aside class="notes">
						// constant velocity so just straight line movement<br/>
						// the interesting part here is creating "depth"<br/>
						//the circles are slightly different sizes and move at different speeds<br/>
						// need to think about gravity
					</aside>
				</section>

				<section data-state="pe2">
					<h2><em class="red">Constraints</em> (gravity)</h2>
				<pre class="med-code">
// simple constraint of gradually increasing gravity
gravity = lerp(0,2,fraction);

// add an amount of gravity to the y velocity
<em class="red">anim.v.y += gravity</em>

// same as before, add the velocity to the position
anim.p.x += anim.v.x
anim.p.y += anim.v.y

// flip velocity for bounce
<em class="red">anim.v.y = -.9*Math.abs(anim.v.y)</em>

// adds a bit of drag to slow down horizonal movement
<em class="red">anim.v.x *= .99;</em>

				</pre>
					<aside class="notes">
						// simple constraint of gradually increasing gravity
						// does not change position necessarily (directly) but acts directly on velocity

						// all this does is add the amount of gravity to the y velocity
						// so y velocity is always going down
						// higher your y velocity, the lower you are on the screen

						//(if same velocity, perfectly elastic collision)
						// the .09 makes it not perfectly elastic
						// friction/gravity

						// fluid, slightly viscous or air drag
						// still goes in same direction but each movement is a bit slower and will head towards 0
						/// tada! Newton's laws in effect

					</aside>
				</section>
				<section data-state="pe2">
					<h2>Separation, <em class="red">Align</em>ment, & Cohesion</h2>
					<pre class="med-code">

// set boids direction towards center
var centroidDirection = vsub(anim1.p, centroid)
var centroidDistance = vlength(centroidDirection)

// apply interaction force against boids
var centroidForce = -attraction / (centroidDistance || .001)
anim1.force.x += centroidForce * centroidDirection.x
anim2.force.x += centroidForce * centroidDirection.x

var rejectForce = <em>rejection</em> / (distance ? distance * distance : 0)
anim1.force.x += rejectForce * direction.x
anim2.force.x += rejectForce * direction.y

// match velocity to nearby boids
anim1.force.x += velocitySync * anim2.v.x
anim2.force.x += velocitySync * anim1.v.x

					</pre>
					<aside class="notes">
						//  Craig Reynolds in 1986 created an artificial life program that he called boids (for bird-oids)<br/>
						// interaction of individual agents adhering to a simple set of rules<br/>
						// Rule 1: Boids try to fly towards the centre of mass of neighbouring boids.<br/>
						// Rule 2: Boids try to keep a small distance away from other objects (including other boids).<br/>
						// Rule 3: Boids try to match velocity with near boids.<br/>
					</aside>
				</section>
				<section data-state="pe2">
					<h2>Collisions (<em class="red">engines</em>!)</h2>
				<pre class="med-code">

// create a world with a ground and some objects
var bodyDef = new Box2D.Dynamics.b2BodyDef();
var fixtureDef = new Box2D.Dynamics.b2FixtureDef();

// set the details for our constraints
fixtureDef.density = 1.0;
fixtureDef.friction = 0.5;

// step through within constraints of our setup
<em class="red">world.Step( 1 / 60 /* frame-rate */,
		10 /* velocity iterations*/,
		1 /* position iterations */);</em>

				</pre>
					<aside class="notes">
						// math gets complex enough here that it is easier to rely on a physics engine to handle the calculations
					</aside>
				</section>

				<section data-state="pe-body">
					<h2>Static <em class="red">&</em> Dynamic</h2>
					<pre class="med-code">
// set body parts oriented in the right direction
torso: partTransitions(0, -.04, .02, .04, -Math.PI/2),
left_arm: partTransitions(-.018, -.03, .01, .03, -3*Math.PI/4),

// sets how parts are attached to each other
fixtureDef.filter.groupIndex = -1

// set up static & dynamic types
addPhysics(anims.head[0], <em>Box2D.Dynamics.b2Body.b2_staticBody</em>, bodyDef, fixtureDef)
groups.slice(1).forEach(function(group) {
addPhysics(anims[group][0], <em>Box2D.Dynamics.b2Body.b2_dynamicBody</em>, bodyDef, fixtureDef)
})

					</pre>
					<aside class="notes">
					// static are like parts of the environment (things can swing off of the static body)
					// dynamics can move throughout a scene freely
					</aside>
				</section>
				

<!-- PERFORMANCE -->

				<section data-state="performance">
					<h2>Per<em class="red">form</em>ance</h2>
					<aside class="notes">
						There are lots of things to consider when you are starting to introduce a lot of animations into your web sites. There isn't one easy answer on how best to approach it but there are some basic guidelines.
					</aside>					
											
				</section>	
				
				<section>
					<h2>HTML, CSS, & JS <em class="red">Base</em>d</h2>
					<ul>						
						<li>Use <em class="red">Keyframes, Transitions & Transforms</em> with CSS</li>
						<li>Use <em class="red">requestAnimationFrame</em> with JS</li>
						<li>Web Animation API (WAAPI)</li>						
					</ul>	
					<aside class="notes">
						<p>CSS is more performant when it comes to basic animations - things get pushed to a different thread</p>
						<p>CSS has a lot of features: 3D transforms, complex backgrounds, etc</p>
						<p>rAF is basically a browser API that is made to optimize concurrent animations together into a single reflow and repaint cycle</p>
						<p>To prevent frames from getting dropped due to too many rendering requests, use requestAnimationFrame. requestAnimationFrame takes a callback that executes when the browser pushes a new frame to the screen. Essentially, the browser pulls for work at each frame, instead of us pushing work for each new touch event. This allows for concurrent animation to fit into one reflow/repaint cycle. As a result, it makes animations look much smoother because the frame rate is consistent.</p>
					</aside>					
				</section>	
				
				<section data-state="rail">
					<h2>RAIL</h2>
					<ul>						
						<li>Response <em class="red">100ms</em></li>
						<li>Animation <em class="red">6ms</em></li>
						<li>Idle  <em class="red">50ms</em></li>
						<li>Load <em class="red">1000ms</em></li>
					</ul>	
					<div class="attribution">credit Paul Irish & Paul Lewis and Blink Team (<a href="http://bit.ly/blink-midnight-train" target="_blank">bit.ly/blink-midnight-train</a>)</div>
					<aside class="notes">
						<p>1000 - loading, 100 - finger down response, 6 - per frame, 50 - idle for cleanup</p>						
						<p>JACOB NEILSON</p>
					</aside>
				</section>
										

				<section data-state="millisecond">
					<!-- http://web-animations.github.io/web-animations-demos/#bounce-timing-function -->
					<aside class="notes">						
						<p>Users have no patience to wait for your UI to load, and once it does they want to make a decision in less than .1 seconds</p>						
					</aside>
				</section>

				<section data-state="canvas-rendering">
					<h2>R<em class="red">end</em>ering</h2>
					<ul>
						<li>Clear & Reuse</li>
						<li>Procedural Sprites</li>
						<li>Keep States</li>
						<li>Compositing</li>

					</ul>
					<aside class="notes">
						<p>Redraw Regions<br/>
							4) Instead of clearing the whole canvas clear only the part which is needed to be cleaned. Its good for performance.

							The best canvas optimization technique for animations is to limit the amount of pixels that get cleared/painted on each frame. The easiest solution to implement is resetting the entire canvas element and drawing everything over again but that is an expensive operation for your browser to process.<br/>
							Reuse as many pixels as possible between frames. What that means is the fewer pixels that need to be processed each frame, the faster your program will run. For example, when erasing pixels with the clearRect(x, y, w, h) method, it is very beneficial to clear and redraw only the pixels that have changed and not the full canvas.
						</p>
						<p>
							Procedural Sprites<br/>
							Generating graphics procedurally is often the way to go, but sometimes that's not the most efficient one. If you're drawing simple shapes with solid fills then drawing them procedurally is the best way do so. But if you're drawing more detailed entities with strokes, gradient fills and other performance sensitive make-up you'd be better off using image sprites.<br/>
							It is possible to get away with a mix of both. Draw graphical entities procedurally on the canvas once as your application starts up. After that you can reuse the same sprites by painting copies of them instead of generating the same drop-shadow, gradient and strokes repeatedly.
						</p>
						<p>State Stack & Transformation<br/>
						The canvas can be manipulated via transformations such as rotation and scaling, resulting in a change to the canvas coordinate system. This is where it's important to know about the state stack for which two methods are available: context.save() (pushes the current state to the stack) and context.restore() (reverts to the previous state). This enables you to apply transformation to a drawing and then restore back to the previous state to make sure the next shape is not affected by any earlier transformation. The states also include properties such as the fill and stroke colors.
						</p>

						<p>Compositing<br/>
							Use multiple layered canvases for complex scenes.

							You may find you have some elements that are frequently changing and moving around whereas other things (like UI) never change. An optimization in this situation is to create layers using multiple canvas elements.

							For example you could create a UI layer that sits on top of everything and is only drawn during user input. You could create game layer where the frequently updating entities exist and a background layer for entities that rarely update.


							A very powerful tool at hand when working with canvas is compositing modes which, amongst other things, allow for masking and layering. There's a wide array of available composite modes and they are all set through the canvas context's globalCompositeOperation property. The composite modes are also part of the state stack properties, so you can apply a composite operation, stack the state and apply a different one, and restore back to the state before where you made the first one. This can be especially useful.</p>
					</aside>
				</section>
				<section data-state="inspect">
					<img src="img/chrome-inspect.png"/>
					<aside class="notes">
						<p></p>
					</aside>
				</section>


						

				<!-- CSS has hardware acceleration for smooth transitions and support is built into the browser, but rules are declared in CSS and require jumping through JavaScript hoops to get values dynamically changed.
requestAnimationFrame has good support and lets the browser optimize when to animate, but it can still hang up if there is a lot of other JavaScript running. It also often requires more math to get timing down.
setInterval introduced many developers to animations, but it is imprecise and can lead to stuttering animations.
jQuery.animate() introduced several other developers to animations, but often has performance issues.
Libraries such as Velocity and GreenSock (GSAP) improve JavaScript performance and have been tested in many situations to be the best they can be. They still, however, require maintaining and loading external libraries. 

The Web Animations API tries to do this. It aims to bring the power of CSS performance, add the benefits and flexibility of JavaScript (and SVG animation, which we will talk about in a future post), and leave it to the browsers to make it work well.
-->				
			
			<section>
				<h2>The future is... <em class="red">meow</em></h2>
				<ul>
					<li><a href="https://iswebvrready.org/" target="_blank"><em class="red">Web</em>VR</a> API</li>
					<li><a href="https://github.com/mrdoob/three.js" target="_blank">Three.<em class="red">js</em></a></li>
					<li><a href="https://unity3d.com/" target="_blank">Un<em class="red">i</em>ty</a></li>
					<li><a href="https://www.unrealengine.com/what-is-unreal-engine-4" target="_blank">Un<em class="red">real</em> Engine</a></li>
					<li><a href="https://aframe.io/" target="_blank">A-Fr<em class="red">a</em>me</a></li>
				</ul>
				<aside class="notes">
					Responsive design can now adapt websites to VR<br/>
					The WebVR API is based on two concepts — sending stereoscopic images to both lenses in your headset and receiving positional data for your head from the sensor, and those two are handled by HMDVRDevice (head-mounted display virtual reality device) and PositionSensorVRDevice.				</aside>
			</section>

			<section>
				<h2>Go <em class="red">play</em>!</h2>
				<aside class="notes">
					So I'd like to encourage you all to go out and play with animations and with these formulas. See what you can do with just an HTML page and some simple JS functions. Play around with the values and find out what types of animations appeal to you.
				</aside>
			</section>


				<section>
					<h2>References & Credits</h2>
					<ul>
						<li>Huge thanks to <a href="https://github.com/acruikshank"><em class="red">Alex Cruikshank</em></a> (@sivoh)</li>
						<li><a href="http://www.amazon.com/Design-Everyday-Things-Donald-Norman/dp/0465067107">Don Norman - The Design of Everyday Things</a></li>						
						<li><a href="https://developers.google.com/web/fundamentals/design-and-ui/animations">Google Web Animation Docs</a></li>
						<li><a href="https://github.com/hecht-software/box2dweb" target="_blank">Box2dWeb</a></li>
					</ul>
				</section>

				<section>
					<img src="img/c5_16_9.png" class="fjs"/>
					<small><a href="http://www.carbonfive.com">Courtney Hemphill</a> <br/> 
						<a href="http://twitter.com/chemphill">@chemphill</a><br/>
						<a href="mailto: courtney@carbonfive.com">courtney@carbonfive.com</a></small>
				</section>
						
			</div>
			
			<div id="show-grid-demo"><iframe src="grid-demo.html" width="100%" height="600" frameborder="0"></iframe></div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
		<script src="js/customEvents.js"></script>	
		<script>
			Reveal.initialize({
				controls: false,
				progress: false,
				history: true,
				center: true,
				theme: Reveal.getQueryHash().theme,
				transition: Reveal.getQueryHash().transition || 'simple', 
				// Optional libraries used to extend on reveal.js
				dependencies: [ { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } } ]
			});		
			Reveal.configure({ keyboard: { 32: checkForSpace } });	
		</script>
	</body>
</html>
